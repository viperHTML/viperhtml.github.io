<!DOCTYPE html>
<html lang="en">
  <head>
    <title>hyperHTML Documentation</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.4.2/css/bulma.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
    <link rel="stylesheet" href="/css/documentation.css">
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/javascript.min.js"></script>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.0.0/highlightjs-line-numbers.min.js"></script>
    <script defer src="https://unpkg.com/hyperhtml@1.0.2"></script>
    <script defer src="js/index.js"></script>
  </head>
  <body>
    <section class="hero is-light">
      <div class="hero-head">
        <header class="nav">
          <div class="container">
            <div class="nav-left">
              <a class="nav-item" href="https://github.com/viperHTML/viperhtml.github.io" title="This Website on GitHub">
                <img width="35" height="28" src="/img/hyperhtml.svg" alt="Logo">
              </a>
              <a class="nav-item" href="https://js.org" target="_blank" title="JS.ORG | JavaScript Community">
                <img width="51" src="https://logo.js.org/dark_horz.png" alt="JS.ORG Logo"/>
              </a>
              <strong class="nav-item">Documentation</strong>
            </div>
            <span class="nav-toggle">
              <span></span>
              <span></span>
              <span></span>
            </span>
            <div class="nav-right nav-menu">
              <a href="/" class="nav-item is-active">
                Home
              </a>
              <!-- a href="https://github.com/WebReflection/hyperHTML" class="button is-inverted" target="_blank">
                <span class="icon">
                    <img width="18" height="18" src="/img/github.svg">
                </span>
                <span>GitHub</span>
              </a -->
            </div>
          </div>
        </header>
      </div>
      <div class="hero-body">
        <div class="columns container is-fluid">
          <div class="column is-one-quarter">
            <aside class="menu">
              <p class="menu-label">
                hyperHTML
              </p>
              <ul class="menu-list">
                <li>
                  <a href="#introduction">Introduction</a>
                  <ul>
                    <li><a href="#introduction-0">what is hyperHTML</a></li>
                    <li><a href="#introduction-1">under the hood</a></li>
                    <li><a href="#introduction-2">performance</a></li>
                  </ul>
                </li>
                <li>
                  <a href="#essentials">Essentials</a>
                  <ul>
                    <li><a href="#essentials-0">installing</a></li>
                    <li><a href="#essentials-01">HTML highlights</a></li>
                    <li><a href="#essentials-11">hyper(HTML)</a></li>
                    <li><a href="#essentials-1">bind VS wire</a></li>
                    <li><a href="#essentials-2">wire types</a></li>
                    <li><a href="#essentials-3">wire ids</a></li>
                    <li><a href="#essentials-3-1">self closing tags</a></li>
                    <li><a href="#essentials-4">attributes vs content</a></li>
                    <li><a href="#essentials-5">boolean attributes</a></li>
                    <li><a href="#essentials-6">events attributes</a></li>
                    <li><a href="#essentials-6-1">style attributes</a></li>
                    <li><a href="#essentials-6-2">data attributes</a></li>
                    <li><a href="#essentials-7">partial attributes</a></li>
                    <li><a href="#essentials-8">content values</a></li>
                    <li><a href="#essentials-9">asynchronous values</a></li>
                    <li><a href="#essentials-10">the placeholder</a></li>
                  </ul>
                </li>
                <li>
                  <a href="#api">API</a>
                  <ul>
                    <li><a href="#api-0">bind</a></li>
                    <li><a href="#api-1">wire</a></li>
                    <li><a href="#api-1-0">wire object</a></li>
                    <li><a href="#api-1-1">wire type</a></li>
                    <li><a href="#api-1-2">wire id</a></li>
                    <!--li><a href="#api-2">escape</a></li-->
                    <li><a href="#api-3">define</a></li>
                    <!--li><a href="#api-4">document</a></li-->
                    <!--li><a href="#api-5">adopt</a></li-->
                  </ul>
                </li>
                <li>
                  <a href="#components">Components</a>
                  <ul>
                    <li><a href="#components-0">good ol' style</a></li>
                    <li><a href="#components-1">modern style</a></li>
                    <li><a href="#components-2">HyperHTMLElement</a></li>
                    <li><a href="#components-3">hyper.Component</a></li>
                  </ul>
                </li>
                <li>
                  <a href="#testing">Testing</a>
                  <ul>
                    <li><a href="#testing-0">NodeJS</a></li>
                    <li><a href="#testing-1">Browsers</a></li>
                  </ul>
                </li>
                <li>
                  <a href="#extras">Extras</a>
                  <ul>
                    <li><a href="#extras-0">about the name</a></li>
                    <li><a href="#extras-1">hyperHTML vs lit-html</a></li>
                  </ul>
                </li>
              </ul>
            </aside>
          </div>
          <div class="column">
            <section id="introduction">
              <h2>Introduction</h2><hr>
              <h3 id="introduction-0">What is hyperHTML?</h3>
              <p>
                hyperHTML is a DOM &amp; ECMAScript standard compliant, zero-dependency, fully cross-platform library
                suitable for <strong>declarative</strong> and
                <strong>reactive</strong> Web Applications.
              </p>
              <p>
                There is nothing new to learn with hyperHTML other than standard JavaScript, HTML, or CSS.
              </p>
              <p>
                Its core features are built on top of <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals">template literals</a>,
                where every interpolation is addressed once, as a unique DOM operation, and updated at lightning-speed when needed.
                Check out <a href="https://webreflection.github.io/hyperHTML/test/tick/">the most basic hyperHTML example</a> below,
                where only the date related content node will change each second.
              </p>
              <pre><code class="javascript">
              function tick(render) {
                // implicit invoke through template literals
                render`
                  &lt;div&gt;
                    &lt;h1 id=${page.id}>Hello, world!&lt;/h1&gt;
                    &lt;!-- dynamic content defined via interpolations --&gt;
                    &lt;h2&gt;It is ${new Date().toLocaleTimeString()}.&lt;/h2&gt;
                  &lt;/div&gt;
                `;
              }

              // update the time each second
              setInterval(tick, 1000,
                hyperHTML.bind(document.body)
              );
              </code></pre>
              <h3 id="introduction-1">Under the hood</h3>
              <p>
                Template literals aren't just better strings,
                they have hidden powers not every developer is aware of.
              </p>
              <p>
                If you have a generic function and place it in front of a template literal
                without invoking it, the function will be executed receiving an Array as its first argument which
                will contain the list of chunks between interpolations,
                the rest of the arguments will contain the interpolated values.
              </p>
              <pre><code class="javascript">
              function template(chunks, ...interpolations) {
                console.log(chunks);          // ['1 ', ' 3']
                console.log(interpolations);  // [2] or [4]
              }

              // look, no parentheses
              template`1 ${2} 3`;
              template`1 ${4} 3`;
              </code></pre>
              <p>
                Not only is the function invoked, its first parameter will be a frozen, unique, Array.
                In this way, even if a template generates different strings due to changed interpolated values,
                its chunks will always be the same.
              </p>
              <pre><code class="javascript">
                const invokes = [];
                function template(chunks, ...interpolations) {
                  invokes.push(chunks);
                  return chunks.join(interpolations[0]);
                }
                  
                // create two different strings
                const foo = x => template`1 ${x} 3`;
                foo(2);
                foo(4);
                
                // verify chunks were exactly the same
                console.assert(
                  invokes[0] === invokes[1],
                  'same unique Array'
                );
                  
                // try a different template literal
                template`${2} 3`; //2 3
                  
                // verify it's different
                console.assert(
                  invokes[1] !== invokes[2],
                  'different template used'
                );                
              </code></pre>
              <p>
                This native feature, even reflected when transpiled via Babel, is key to generating a DOM structure and parsing it once, 
                creating a unique relationship between a template literal and a DOM template. 
              </p>
              <p>
                What hyperHTML adds on top of this feature is a context to operate in,
                like a context you could use for any generic function or method call.
              </p>
              <pre><code class="javascript">
              // bind hyperHTML to a generic DOM container
              const bodyRender = hyperHTML.bind(document.body);

              // use it to declare any layout you needed
              bodyRender`
                &lt;h1&gt;${document.title}&lt;/h1&gt;
                &lt;ul&gt;
                  ${[
                    {name: 'First item'},
                    {name: 'Second item'},
                    {name: 'Third item'}
                  ].map(item =&gt;
                  `&lt;li&gt;${item.name}&lt;/li&gt;`)}
                &lt;/ul&gt;
              `;
              </code></pre>
              <p>
                View the example above on <a href="https://codepen.io/WebReflection/pen/brrNRp?editors=0010">Code Pen</a>.
              </p>
              <p>
                Strawberry on top, hyperHTML uses the <a href="https://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein distance algorithm</a> to update internal list of items or node,
                resulting in the least amount of needed DOM operation to <a href="https://twitter.com/WebReflection/status/930920579938619392">make a list of nodes become another list</a>.
              </p>
              <h3 id="introduction-2">Performance</h3>
              <p>
                It doesn't matter if it's a <a href="https://webreflection.github.io/hyperHTML/test/dbmonster.html">DBMonster</a>, 
                <a href="https://webreflection.github.io/hyperHTML/test/double-rainbow.html"> a thousand SVGs</a>,
                a <a href="https://webreflection.github.io/hypermvc/index.html">TodoMVC</a> challenge,
                or a <a href="https://viperhtml-164315.appspot.com/top/1">Hacker News PWA</a>,
                hyperHTML gives you performance by default thanks to these simple facts: 
              </p>
              <ul>
                <li>it's really lightweight, weighing around <strong>4.5KB</strong> via brotli. That's all the bandwidth budget you and your users need.</li>
                <li>it doesn't double RAM or CPU usage via Virtual DOM operations, it <strong>doesn't use a Virtual DOM at all!</strong></li>
                <li>it's fully based on ECMAScript <strong>standard</strong> and DOM <strong>specifications</strong></li>
              </ul>
              <p>
                The last point means that it's hard to perform much faster than hyperHTML in a similar
                minimalistic, elegant, yet powerful and expressive way,
                every other framework will inevitably end up manipulating the DOM.
              </p>
              <p>
                hyperHTML just sits already there with direct access to every node or attribute change.
              </p>
              <p>
                Read the <a href="#essentials">essentials</a> to learn how to start using it.
              </p>
            </section>
            <section id="essentials">
              <h2>Essentials</h2><hr>
              <h3 id="essentials-0">Installing</h3>
              <p>
                You can include hyperHTML at the top of your page, using <a href="https://unpkg.com/#/">unpkg</a> CDN.
              </p>
              <pre>&lt;script src="https://unpkg.com/hyperhtml@latest/min.js"&gt;&lt;/script&gt;</pre>
              <p>
                Alternatively, you can install the <a href="https://www.npmjs.com/package/hyperhtml">npm CJS package</a> and require it later on.
              </p>
              <pre>npm i --save hyperhtml</pre>
              <p>
                If you use Babel to transpile template literals, your browser should be compatible with the following ES5 methods:
              </p>
              <ul>
                <li>Object.defineProperty</li>
                <li>Object.defineProperties</li>
              </ul>
              <p>
                If you need a polyfill for the methods above
                you can use <a href="https://polyfill.io/v2/docs/">polyfill.io</a>
                or <a href="https://github.com/es-shims/es5-shim">ES5 shims and shams</a>.
              </p>
              <h3 id="essentials-11">hyper(HTML)</h3>
              <p>
                The default <code>hyper</code> exported function, can be used
                to create DOM nodes at runtime, populate existent nodes,
                or weakly relate objects with nodes.
              </p>
              <p>
                All these operations are available, as shortcut, through the following usage:
              </p>
              <ul>
                <li><code>hyper`&lt;p&gt;runtime&lt;/p&gt;`</code> to create new DOM content each time<br><small>(shortcut for <code>.wire()`...`</code>)</small></li>
                <li><code>hyper(node)`&lt;p&gt;internal content&lt;/p&gt;`</code> to populate <code>node</code> once with smart DOM content<br><small>(shortcut for <code>.bind(node)`...`</code>)</small></li>
                <li><code>hyper(obj, id)`&lt;li&gt;wired content&lt;/li&gt;`</code> to create new DOM content<br><small>(shortcut for <code>.wire(obj, id)`...`</code>)</small></li>
              </ul>
              <p>
                While using <code>hyper`&lt;p&gt;runtime&lt;/p&gt;`</code> for one-off operations <i>just works</i>,
                binding a DOM node to create its own content or weakly relating generic objects are the best way to recycle the DOM and obtain best performance.
              </p>
              <h3 id="essentials-01">HTML Syntax Highlight</h3>
              <p>
                If you are using Visual Studio Core you can install <code>literally-html</code>.
              </p>
              <img style="max-width:320px;" src="img/literally-html.png">
              <h3 id="essentials-1">Bind VS Wire</h3>
              <img style="max-width:320px;" src="img/hyperhtml-learnig-api.png">
              <p>
                There are two basic mechanisms to create DOM nodes in hyperHTML:
              </p>
              <ul>
                <li>declaring the layout <strong>inside an existing DOM node</strong>,
                like you would do on a <code>document.body</code>,
                a <code>document.getElementById('node')</code> target node,
                or a Custom Element node and eventually its Shadow DOM</li>
                <li><strong>declaring new DOM nodes</strong> and their content,
                like you would do for a list of table rows, LIs, paragraphs,
                articles, etcetera.</li>
              </ul>
              <p>
                In the first case, you will need to <strong>bind</strong> the node as hyperHTML context.
                In the latter case, you would <strong>wire</strong> the declared content,
                optionally passing it an object.
              </p>
              <pre><code class="javascript">
              const {bind, wire} = hyperHTML;

              // find a container to render the layout
              bind(document.querySelector('ul'))`${
                // fill it up with wired items
                listOfItems.map(
                  // any object can be wired
                  // to a declarative content
                  item =>
                  // this will return, per each item
                  // an actual &lt;LI&gt; DOM node
                  wire(item)`&lt;li&gt;${item.name}&lt;/li&gt;`
                )
              }`;
              </code></pre>
              <p>
                To render and update nodes multiple times, you need to bind them as context.
              </p>
              <p>
                To create nodes on the fly, without rendering,
                you can use wires.
              </p>
              <pre><code class="javascript">
              const singleWire = hyperHTML.wire()`
                &lt;li&gt;node&lt;/l&gt;`;

              const multiWire = hyperHTML.wire()`
                &lt;li&gt;a&lt;/l&gt;
                &lt;li&gt;b&lt;/l&gt;
                &lt;li&gt;c&lt;/l&gt;`;
              </code></pre>
              <p>
                To properly render the wired variables, you will need a bound context to operate.
              </p>
              <pre><code class="javascript">
                hyperHTML.bind(document.body)`
                &lt;ul&gt;
                  ${singleWire}
                  ${multiWire}
                &lt;/ul&gt;`;
              </code></pre>
              <h3 id="essentials-2">Wire Types</h3>
              <p>
                When you bind a generic DOM node, it's easy for the library to understand what kind of node it is.
              </p>
              <p>
                However, when you wire nodes at runtime,
                it's important to distinguish between <code>html</code> nodes,
                the assumed default, and <code>svg</code> nodes,
                which require special treatment during their creation.
              </p>
              <pre><code class="javascript">
              const point = {x: 1, y: 2};
              hyperHTML.bind(document.body)`
              &lt;svg&gt;
                ${hyperHTML.wire(point, 'svg')`
                &lt;rect x=${point.x} y=${point.y} /&gt;`}
              &lt;/svg&gt;`;
              </code></pre>
              <p>
                By default, the <code>html</code> type is assumed,
                but a non SVG element, even if appended inside another SVG element, won't produce the same result.
                The wire type is there to solve this ambiguity, when needed,
                as a runtime created node cannot know upfront its parent's node type.
              </p>
              <h3 id="essentials-3">Wire IDs</h3>
              <p>
                A wire can be created without references
              </p>
              <pre><code class="javascript">
              const newLI = hyperHTML.wire()`&lt;li&gt;&lt;/li&gt;`;
              </code></pre>
              <p>
                But it could also be created once, weakly relating its content to a generic object.
              </p>
              <pre><code class="javascript">
              const info = {some: 'data'};
              const sameLI = hyperHTML.wire(info)`
                              &lt;li&gt;&lt;/li&gt;`;

              // what if we use same template later on?
              console.assert(
                sameLI === hyperHTML.wire(info)`
                              &lt;li&gt;&lt;/li&gt;`,
                'same reference means exactly the same node'
              );
              </code></pre>
              <p>
                However, a single object could be the source of many pieces of layout.<br>
                Think about a generic <code>user</code> object.
              </p>
              <p>It could be used to generate:</p>
              <ul>
                <li>a settings page</li>
                <li>an avatar</li>
                <li>a profile summary</li>
                <li>some contact details</li>
              </ul>
              <p>
                In all these cases you want to create the layout once per user,
                reusing as much as possible so that <code>user</code> has a weak reference to its layouts.
              </p>
              <p>
                This is where specifying an id comes in handy, as it allows each user
                scenario to have multiple layouts associated with it.
              </p>
              <pre><code class="javascript">
              function createView(user) {
                const wire = hyperHTML.wire;
                const avatar = wire(user, ':avatar')`
                    &lt;img width=80 src=${user.image}&gt;`;
                return {
                  avatar: avatar,
                  profile: wire(user, ':profile')`
                    &lt;h1&gt;${user.name}&lt;/h1&gt;
                    ${avatar}
                    &lt;p&gt;${user.phone}&lt;/p&gt;`
                };
              }

              // show the user profile
              hyperHTML.bind(document.body)`
              ${createView(userObject).profile}`;
              </code></pre>
              <p>
                View the result on <a href="https://codepen.io/WebReflection/pen/dzzYgm?editors=0010">Code Pen</a>.
              </p>
              <p>
                IDs are also <strong>compatible with types</strong>.
                <br>For example, <code>hyperHTML.wire(obj, 'svg:point')`&lt;rect /&gt;`</code> is perfectly valid.
              </p>
              <h3 id="essentials-3-1">Self Closing Tags</h3>
              <p>
                Directly borrowed from XML, or if you want JSX, both bound and wired content
                is capable of understanding self-closing tags.
              </p>
              <pre><code class="javascript">
              const p = hyperHTML.wire()`&lt;p class="${any}" /&gt;`;
              hyperHTML.bind(p)`&lt;i class=${fontIcon} /&gt;`;
              </code></pre>
              <p>
                Self closing tags are also particularly useful with <code>&lt;custom-elements/&gt;</code>
              </p>
              <h3 id="essentials-4">Attributes vs Content</h3>
              <p>
                By now it should be clear how to create nodes inside an existing element or on the fly.
                While this is great content-wise, we haven't talked much about attributes and what's possible with them.
              </p>
              <p> Here's a list:</p>
              <ul>
                <li>every attribute can be defined with quotes or, if the whole attribute is a template literal hole, without quotes.</li>
                <li>attribute values can be one of 6 types:
                  <ul>
                    <li>text, as <strong>string</strong>, for any kind of attribute</li>
                    <li><strong>boolean</strong> <code>true</code> or <code>false</code> for special attributes such <code>disabled</code> and others</li>
                    <li><strong>function</strong> or <strong>object</strong> for custom or native events, or to assign a <code>style</code> attribute</li>
                    <li>either <strong>null</strong> or <strong>undefined</strong> to explicitly clean or remove attributes of any kind, or to remove listeners</li>
                  </ul>
                </li>
              </ul>
              <p>
                Every node can have one or more attributes defined in a similar way.
              </p>
              <pre><code class="javascript">
              hyperHTML.bind(form)`
              &lt;input
                class=${['one', 'more', 'class'].join(' ')}
                disabled=${!isAuthorized}
                oninput=${e => document.title = e.target.value}
                value=${defaultInputValue}
                placeholder=${'type something'}
              &gt;`;
              </code></pre>
              <h3 id="essentials-5">Boolean Attributes</h3>
              <p>
                Whenever an attribute has a special meaning, and it should be present or not,
                we can use boolean attribute values.
              </p>
              <pre><code class="javascript">
              // this will generate
              // &lt;button disabled&gt;click me if you can&lt;/button&gt;
              hyperHTML.bind(form)`
              &lt;button disabled=${true}&gt;
                click me if you can
              &lt;/button&gt;`;

              // this will generate
              // &lt;button&gt;click me if you can&lt;/button&gt;
              hyperHTML.bind(form)`
              &lt;button disabled=${false}&gt;
                click me if you can
              &lt;/button&gt;`;
              </code></pre>
              <p>
                The same concept works for <code>defer</code>, <code>async</code>, links <code>download</code>,
                or even <code>contenteditable</code>. Just use boolean attributes any time you need them,
                if it's part of the element's inheritance, it'll always do the right thing.
              </p>
              <h3 id="essentials-6">Events Attributes</h3>
              <p>
                The <a href="https://en.wikipedia.org/wiki/DOM_events#DOM_Level_0">DOM Level 0</a> introduced inline HTML events a very long time ago.
                These can be represented as strings in the layout within the element definition,
                or as a direct property accessor like <code>link.onclick = callback</code>.
              </p>
              <p>
                hyperHTML takes declarative events to the next level:
                you can assign them as DOM Level 3 shortcuts for <code>addEventListener</code> or,
                if the event is <code>null</code>, as a shortcut for <code>removeEventListener</code>.
              </p>
              <p>
                This means that as long as an attribute name is prefixed with <strong>on</strong>,
                every possible event can be assigned, either as a function,
                or as <a href="https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38">an object</a>,
                through its <code>handleEvent</code> method.
              </p>
              <pre><code class="javascript">
              function click(e) {
                e.preventDefault();
                alert('You wish! Muahahaha');
              }
              const site = 'http://google.com';;
              const text = 'search something';
              hyperHTML.bind(document.body)`
              &lt;a href=${site} onclick=${click}&gt;${text}&lt;/a&gt;`;
              </code></pre>
              <p>
                When it comes to creating DOM components,
                having the <code>handleEvent</code> mechanism out of the box
                is a very welcome, standard feature.
              </p>
              <pre><code class="javascript">
              function Login(user, pass) {
                this.validated = false;
                this._user = user;
                this._pass = pass;
                this.html = hyperHTML.wire(this);
                return this.render();
              }

              Login.prototype.handleEvent = function (e) {
                this[e.target.name] = e.target.value;
                this.validated = (
                  this.user === this._user &amp;&amp;
                  this.pass === this._pass
                );
                this.render();
              };

              Login.prototype.render = function () {
                return this.html`
                &lt;form
                  method=post
                  action=/admin
                  onsubmit=${e => {
                    e.preventDefault();
                    alert('You made it!');
                  }}
                  &gt;
                  &lt;input name=user oninput=${this}&gt;&lt;br&gt;
                  &lt;input name=pass oninput=${this} type=password&gt;&lt;br&gt;
                  &lt;input
                    value='admin area'
                    type=submit
                    disabled=${!this.validated}&gt;
                &lt;/form&gt;`;
              };

              document.body.appendChild(
                new Login('super', 'secret')
              );
              </code></pre>
              <p>
                View the example above on <a href="https://codepen.io/WebReflection/pen/Yxxqwy?editors=0010">Code Pen</a>.
              </p>
              <p>
                Bear in mind that runtime assigned listeners will inevitably remove and re-add themselves since
                two functions, even if identical, are always different in JavaScript.
                This means that while the previous example works fine for demo purposes,
                the <em>onsubmit</em> listener should be defined elsewhere and not inline.
              </p>
              <h3 id="essentials-6-1">Style Attributes</h3>
              <p>
                Fully inspired by <a href="https://preactjs.com">Preact</a> implementation,
                <code>style</code> attributes can be updated via both strings, like any other regular attribute,
                or via an object.
              </p>
              <pre><code class="javascript">
              hyper(ref)`&lt;p style=${{fontSize: 32}}&gt;${'BIG CONTENT'}&lt;/p&gt;`;
              </code></pre>
              <h3 id="essentials-6-2">The data Attribute</h3>
              <p>
                Whenever you need to pass raw JS data down the element,
                <code>data=${anyObject}</code> is the way to go.
              </p>
              <p>
                The following code will log in console exactly the <code>user</code> reference.
                No JSON is involved whatsoever in the process.
              </p>
              <pre><code class="javascript">
              hyper(ref)`&lt;p onconnected=${function () { console.log(this.data); }} data=${user} /p&gt;`;
              </code></pre>
              <p>
                If you, however, find yourself restricted by <code>data</code>, big news for you: hyperHTML doesn't lock you in and it lets you free to implement it as follows for instance.
              </p>
              <pre><code class="javascript">
              customElements.define(
                'h-welcome',
                class HyperWelcome extends HTMLElement {
                  get html() { return this._html || (this._html = hyperHTML.bind(this)); }
                  
                  get user() {
                    return this._user;
                  }
                
                  set user(value) {
                    this._user = value;
                    this.render();
                  }
                  
                  render() {
                    return this.html`&lt;h1>Hello, ${this._user.name}&lt;/h1&gt;`;
                  }
                }
              );
              
              hyperHTML.bind(document.getElementById('root'))`
                &lt;h-welcome user=${{ name: 'Sara' }} /&gt;
                &lt;h-welcome user=${{ name: 'Cahal' }} /&gt;
                &lt;h-welcome user=${{ name: 'Edite' }} /&gt;
              `;
              </code></pre>
              <p>
               View the example above on <a href="https://codepen.io/jiayihu/pen/QVqNGJ?editors=0010">Code Pen</a>
              </p>
              <h3 id="essentials-7">Partial Attributes (now supported)</h3>
              <p>
                Since version <code>2.30</code>, <strong>partial attributes are supported</strong> out of the box.
                However, before such version there was no support whatsoever, and following is why.
              </p>
              <p>
                Differently from other libraries, partial attributes are not supported but there are
                many ways to achieve the same goal via a single definition.
              </p>
              <p>
                <strong>Why no partial attributes?</strong><br>
                Template literal interpolations can also contain other template literals.<br>
                Accordingly, there is no reason to compromise performance and over-complicate attributes logic.<br>
                As result, partial attributes were considered <acronym title="You Ain't Gonna Need It">YAGNI</acronym>
                during the architecture design of the engine.
              </p>
              <p>The following example shows several ways to update an attribute correctly as well as the wrong way, mentioned above.</p>
              <pre><code class="javascript">
              // THE FOLLOWING IS OK 👍
              html`&lt;div class=${`foo ${mayBar ? 'bar' : ''}`}&gt;Foo bar?&lt;/div&gt;`;
              html`&lt;div class=${'foo' + (mayBar ? ' bar' : '')}&gt;Foo bar?&lt;/div&gt;`;
              html`&lt;div class=${['foo', mayBar ? 'bar' : ''].join(' ')}&gt;Foo bar?&lt;/div&gt;`;
              html`&lt;div style=${`top:${top}; left:${left};`}&gt;x&lt;/div&gt;`;

              // THE FOLLOWING BREAKS ⚠️
              html`&lt;div style="top:${top}; left:${left};"&gt;x&lt;/div&gt;`;
              </code></pre>
              <p>
                It's also misleading to think that an attribute can be partially modified.<br>
                Whenever you change a single portion of an attribute,
                the browser needs to figure out what to do with the change as a whole, so: no partial attributes.
              </p>
              <h3 id="essentials-8">Content Values</h3>
              <p>
                Content values also have their own rules and features.
              </p>
              <ul>
                <li>
                  if content is text, as <strong>string</strong>, or any other primitive such as <strong>number</strong>, or <strong>boolean</strong>, this will be injected as <code>textContent</code> hence sanitized <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">against XSS</a>.<br>
                  This makes hyperHTML <em>safe by default</em>, but it could be even safer ( <small>keep reading</small> )
                </li>
                <li>
                  if the content is a <strong>DOM Node</strong>, it will be simply appended in place.<br>
                  This is necessary to make wires work within other templates but you can use this feature as you prefer.
                </li>
                <li>
                  if the content is a <strong>Promise</strong>, it will be assigned once resolved.
                  The resulting value can be of <em>any</em> understood type in this list.
                </li>
                <li>
                  if the content is an <strong>Array</strong>, it's an explicit intent to perform one of the following operations:
                  <ul>
                    <li>if it's an array of <strong>strings</strong>, they will be injected as explicit opt-in for <em>HTML</em></li>
                    <li>if it's an array of <strong>DOM Nodes</strong>, they will be appended in place, which plays well with multi node wires.</li>
                    <li>if it's an array of <strong>Promises</strong>, they will be placed once all promises are resolved, with <em>any</em> returned value</li>
                  </ul>
                </li>
                <li>
                  if the content is an <strong>Object</strong>, it's an explicit intent to perform one of the following operations:
                  <ul>
                    <li>if it has a <strong>text</strong> property, it will force whatever value as sanitized string, hence XSS free <em>text content</em></li>
                    <li>if it has a <strong>html</strong> property, it will force whatever value as string, injecting it as <em>HTML</em></li>
                    <li>if it has an <strong>any</strong> property, it will resolve whatever content it has, compatibly with all understood types</li>
                    <li>if none of the following is true, hyperHTML will try to find out if it has the type <strong>defined</strong> in its registry.<br>
                    In which case, it will pass along whatever value it is to the defined callback,
                    and it will parse the resulting object against the types in this list.</li>
                  </ul>
                </li>
                <li>
                  if content is either <strong>null</strong>, or <strong>undefined</strong>, that part of the content will be cleared
                </li>
              </ul>
              <p>
                The following example shows possible opt-in/out intents.
              </p>
              <pre><code class="javascript">
              function html(render) {
                return render`
                  &lt;!-- text by default for strings --&gt;
                  &lt;p&gt;Hello ${'World'}&lt;/p&gt;
                  &lt;!-- text as explicit intent --&gt;
                  &lt;p&gt;Hello ${{text: 'World'}}&lt;/p&gt;
                  &lt;select&gt;
                    &lt;!-- any by default for no-strings,
                         Arrays are opt-in for HTML --&gt;
                    ${['a', 'b'].map(v =&gt; `&lt;option value="${v}"&gt;${v}&lt;/option&gt;`)}
                  &lt;/select&gt;
                  &lt;!-- html as explicit intent --&gt;
                  &lt;p&gt;Hello ${{html: '&lt;strong&gt;World&lt;/strong&gt;'}}&lt;/p&gt;
                  &lt;!-- any content as explicit intent --&gt;
                  &lt;p&gt;Hello ${{any: fetch('thing').then(b =&gt; b.text())}}&lt;/p&gt;
                  &lt;!-- will be resolved as text so it'll be textContent --&gt;
                `;
              }
              </code></pre>
              <p>
                To define an intent with its own transformer,
                you can use the <code>define</code> method.
              </p>
              <pre><code class="javascript">
              // define an encode intent
              hyperHTML.define(
                'encoded',
                encodeURIComponent
              );

              // use it like any other intent
              const text = 'a + b';
              html`&lt;p&gt;encoded ${{text}} is ${{encoded: text}}&lt;/p&gt;`;
              // &lt;p&gt;encoded a + b is a%20%2B%20b&lt;/p&gt;
              </code></pre>
              <h3 id="essentials-9">Asynchronous Values</h3>
              <p>
                Core compatibility with Promises means you can import layouts
                asynchronously and return them once resolved.
                This was key to making <a href="https://hnpwa.com/">Viper News HNPWA</a>, 
                one of the fastest to bootstrap, despite being 100% <acronym title="Server Side Rendered">SSR</acronym>.
              </p>
              <p>
                However, having promises means there's no way to show content while waiting for them to resolve.
                To solve this issue, you can use an extra builtin transformer called <code>placeholder</code> which will 
                provide content before the promise resolves.
              </p>
              <h3 id="essentials-10">The Placeholder</h3>
              <p>
                Every intent can be set up asynchronously
                by simply using the <code>placeholder</code> property.
              </p>
              <p>
                This property can be any content type listed above, although it wouldn't make sense to have this property asynchronous too.
              </p>
              <pre><code class="javascript">
              // fetch the list and render it as HTML
              html`&lt;ul&gt;
                ${{
                  html: fetch('/grocery').then(b => b.text()),
                  placeholder: 'Loading list ...'
                }}
              &lt;/ul&gt;`;

              // or wire some content
              html`&lt;ul&gt;
                ${{
                  any: fetch('/grocery.json')
                        .then(b => b.json())
                        .then(list => list.map(
                          item => hyperHTML.wire()
                          `&lt;li data-id=${item.id}&gt;${item.name}&lt;/li&gt;`
                        )),
                  placeholder: spinner.cloneNode(true)
                }}
              &lt;/ul&gt;`;
              </code></pre>
              <p>
                View a basic example of <code>placeholder</code> on
                <a href="https://codepen.io/WebReflection/pen/MvveOw?editors=0010">Code Pen</a>.
              </p>
            </section>
            <section id="api">
              <h2>API</h2><hr>
              <p>
                Even though hyperHTML is a function, it should be used as a namespace.<br>
                Every method is detached from its context so that you can easily
                destructure them.
              </p>
              <pre><code class="javascript">
              const {bind:hyper, wire} = hyperHTML;

              hyper(document.body)`
                ${wire()`&lt;h1&gt;Hello Content&lt;/h1&gt;`}
              `;
              </code></pre>
              <h3 id="api-0">hyperHTML.bind(DOMElement)</h3>
              <p>
                Used as <code>Function.prototype.bind</code> subset,
                since you cannot bind extra arguments 'cause these are not handled by template literals,
                <code>bind(el)</code> is the method to use when you want to populate an element with some content.
              </p>
              <p>
                The element must exist already, and must be a valid HTML Element.
              </p>
              <pre><code class="javascript">
              const {bind, wire} = hyperHTML;
              bind(document.querySelector('main'))`
                &lt;section id=${info.id}&gt;
                  &lt;h2&gt;${info.title}&lt;/h2&gt;
                  ${info.articles.map(article =&gt; wire(article)`
                    &lt;article&gt;${article.author}&lt;/article&gt;`)}
                &lt;/section&gt;`;
              </code></pre>
              <h3 id="api-1">hyperHTML.wire([obj[, type:id]])</h3>
              <p>
                Whenever you want to create a container, instead of populating one,
                or when you want to create some DOM content at runtime,
                <code>wire()`&lt;p&gt;hello&lt;/p&gt;`</code> is the way to go.
              </p>
              <pre><code class="javascript">
              const {wire} = hyperHTML;
              const name = 'World';

              // wire() to create an element
              document.body.appendChild(
                wire()`&lt;h1&gt;Hello &lt;em&gt;${name}&lt;/em&gt;!&lt;/h1&gt;`
              );
              </code></pre>
              <p>
               View the example above on <a href="https://codepen.io/WebReflection/pen/dzzaJo?editors=0010">Code Pen</a>
              </p>
              <p>
                If you'd like to use <code>wire</code> like a generic <code>html</code> content creator,
                you can use a very simple utility like the following one:
              </p>
              <pre><code class="javascript">
              // a wire itself is just a function used with
              // template literals. You can pass values right away.
              const html = (...args) => hyperHTML.wire()(...args);

              document.body.appendChild(
                html`&lt;p&gt;this is so easy&lt;/p&gt;`
              );
              </code></pre>
              <p>
                You can also create more than one element per wire.
                In these cases though, hyperHTML will produce an array,
                so that once appended as list of nodes, it won't lose references
                like a document fragment would.
              </p>
              <p>
                Since by standard specification you cannot append an Array to a generic element,
                you need to bind the target container in order to make <strong>multi-wires</strong> work.
              </p>
              <pre><code class="javascript">
              const {bind, wire} = hyperHTML;
              const name = 'Andrea';
              const surname = 'Giammarchi';
              
              // multi-wire
              const myDetails = wire()`
                &lt;p&gt;${name}&lt;/p&gt;
                &lt;p&gt;${surname}&lt;/p&gt;`;
              
              // handled like a fragment
              // when passed to a bound element
              bind(document.body)`
              &lt;div&gt;
                ${myDetails}
              &lt;/div&gt;`;
              </code></pre>
              <p>
                View the example above on <a href="https://codepen.io/WebReflection/pen/prrGLZ?editors=0010">Code Pen</a>
              </p>
              <h3 id="api-1-0">Wiring an object</h3>
              <p>
                The strongest hyperHTML point is the ability to recycle and address every DOM node.
                However, when you wire elements at runtime, you are creating a fresh new element every time.
              </p>
              <p>
                While in most cases this is not necessarily a performance issue,
                there is a larger amount of RAM and CPU operations needed that can be avoided.
              </p>
              <p>
                The easiest way to do this, is by weakly relating a generic object to a generic wired content.
              </p>
              <pre><code class="javascript">
              const {bind:hyper, wire} = hyperHTML;
              
              const todo = [
                {id: 0, text: 'write documentation'},
                {id: 1, text: 'publish online'}
              ];
              
              // show the todo list
              update();
              
              // add an item in 2 seconds
              setTimeout(() => {
                todo.push({
                  id: 2, text: 'create Code Pen'
                });
                update();
              }, 2000);
              
              function update() {
                hyper(document.body)`
                &lt;ul&gt;
                  ${todo.map(item =&gt; wire(item)
                  `&lt;li&gt;${item.text}&lt;/li&gt;`)}
                &lt;/ul&gt;`;
              }
              </code></pre>
              <p>
                As you can see on <a href="https://codepen.io/WebReflection/pen/qXXgJd?editors=0010">Code Pen</a>,
                the second time the <code>update()</code> function is called
                the only change that happens to the DOM
                is that the new list item is appended to the end of the <em>UL</em> element.
              </p>
              <p>
                This happens because elements wired to a generic object will not be created again,
                these will simply be exact same element and when it comes to list of same elements,
                hyperHTML does nothing but leaving these there.
              </p>
              <h3 id="api-1-1">Wiring SVGs</h3>
              <p>
                Beside relating wired content to objects,
                we might want to specify the kind of content we are going to create.
              </p>
              <p>
                There are currently 2 types of elements accepted by hyperHTML:
              </p>
              <ul>
                  <li><strong>html</strong> elements, used as default</li>
                  <li><strong>svg</strong> elements, needing a special treatment</li>
              </ul>
              <p>
                While hyperHTML can easily understand a bound element type,
                when you create a new element it's quite impossible to determine
                if you wanted the element as an SVG, a custom element or ... both ?
              </p>
              <p>
                The optional second parameter for <code>hyperHTML.wire()</code> lets you explicitly define which type.
              </p>
              <pre><code class="javascript">
              // returns an SVG rect shape element
              hyperHTML.wire(null, 'svg')`&lt;rect /&gt;`;

              // but by default, it would create just
              // an HTML rect element with no special meaning
              hyperHTML.wire()`&lt;rect /&gt;`;
              // same as
              hyperHTML.wire(null)`&lt;rect /&gt;`;
              // or as
              hyperHTML.wire(null, 'html')`&lt;rect /&gt;`;
              </code></pre>
              <h3 id="api-1-2">Multi wired objects</h3>
              <p>
                Now that we know how to relate some DOM content to a specific object,
                and how to define its type,
                we can move to the next step: using the same object to render multiple content.
              </p>
              <p>
                To do this, all we need is an <strong>id</strong>, defined with a colon <code>:</code> prefix.
                The reason for specifying it as colon and not <code>#</code> was to avoid confusion with DOM ids.
                In this case we are referencing a generic name, or description, the template is used in relation to the generic object.
              </p>
              <pre><code class="javascript">
              const {bind:hyper, wire} = hyperHTML;
              
              const todo = [
                {id: 0, text: 'write documentation'},
                {id: 1, text: 'publish online'}
              ];
              
              update();
              
              function update() {
                hyper(document.body)`
                &lt;style&gt;
                .todo-id {
                  display: inline-block;
                  margin: 4px;
                  background-color: #eee;
                  padding: 4px;
                }
                &lt;/style&gt;
                &lt;p&gt;
                  The list has the following IDs:
                  ${todo.map(item =&gt; wire(item, ':id')`
                  &lt;span class=todo-id&gt;${item.id}&lt;/span&gt;`)}
                &lt;/p&gt;
                &lt;ul&gt;
                  ${todo.map(item =&gt; wire(item, ':list')
                  `&lt;li data-id=${item.id}&gt;${item.text}&lt;/li&gt;`)}
                &lt;/ul&gt;`;
              }
              </code></pre>
              <p>
                You can verify on <a href="https://codepen.io/WebReflection/pen/brrzyM?editors=0010">Code Pen</a>
                that calling <code>update()</code> multiple time will not trash the previous content,
                and objects can be related multiple times with different wired content.
              </p>
              <p>
                To specify a different kind of element and an id, you can simply write the kind upfront.
              </p>
              <pre><code class="javascript">
              // default as html
              hyperHTML.wire(obj, ':id');
              // same as
              hyperHTML.wire(obj, 'html:id');

              // but different from
              hyperHTML.wire(obj, 'svg:id');
              </code></pre>
              <!--
              <h3 id="api-2">hyperHTML.escape(text)</h3>
              <p>
                Before introducing <em>intents</em> through objects literals,
                such <code>${{text}}</code> or <code>${{html}}</code>,
                it wasn't possible to specify HTML escaped content.
              </p>
              <p>
                Since <em>escaping</em> is a useful utility
                when you deal with HTML documents,
                hyperHTML kept this method around.
              </p>
              <pre><code class="javascript">
              const {escape} = hyperHTML;
              escape(`&lt;&#39;&amp;&quot;&gt;`);
              // &amp;lt;&amp;#39;&amp;amp;&amp;quot;&amp;gt;
              </code></pre>
              -->
              <h3 id="api-3">hyperHTML.define(intent, callback)</h3>
              <p>
                You can extend hyperHTML intents by defining a name and a callback.
                This mechanism is basically the same used to explicitly opt-in for
                text, html, or any other accepted value, including attributes.
              </p>
              <p>
                This callback will receive whatever interpolated value is passed along,
                and its returned value will be used as the transformation.
              </p>
              <p>
                If the name contains one or more hyphens <code>-</code>,
                the intent would be set for attributes instead,
                and the callback will receive the node element,
                and the interpolated value passed along.
                Its optionally returned value will be used as attribute value.
              </p>
              <p>
                This value can be anything, including an intent itself.
              </p>
              <pre><code class="javascript">
              hyperHTML.define(
                'adminArea',
                (credentials) => {
                  const form = new FormData();
                  form.append('user', credentials.user);
                  form.append('pass', credentials.pass);
                  return {
                    any: fetch('/auth', {
                          method: 'POST',
                          body: form
                        })
                        .then(b => b.json())
                        .then(ok => {
                          if (ok) return view.adminArea;
                          else return 'failed to authenticate';
                        }),
                    'placeholder': 'authorizing user ...'
                  };
                }
              );

              hyperHTML.define(
                'color-style',
                (node, value) => {
                  node.style.cssText = `color:${value};`;
                  return value;
                }
              );

              hyperHTML.bind(document.body)`
              &lt;section color-style=${'red'} id="info"&gt;
                ${'Welcome'}
              &lt;/section&gt;
              &lt;section id="admin"&gt;
                ${{adminArea: {
                  user: 'andrea',
                  pass: '4ndr34'
                }}}
              &lt;/section&gt;`;
              </code></pre>
              <h4>Why is this needed?</h4>
              <p>
                Instead of polluting the local or global scope
                with extended behaviors, hyperHTML templates can always have extensions
                even when not defined.
              </p>
              <p>
                This makes intents and templates completely independent
                from the surrounding scope, giving developers the ability to test them in isolation.
              </p>
              <p>
                You could even mock intents, if it's testing you are after,
                and forget about real definitions and dependencies.
              </p>
              <pre><code class="javascript">
              const runtimeIntent = () => {};
              
              hyperHTML.bind(document.body)`
                &lt;p&gt;
                  This is fine.
                &lt;/p&gt;
                &lt;p&gt;
                  ${{runtimeIntent}}
                &lt;/p&gt;`;
              </code></pre>
              <!--h3 id="api-4">hyperHTML.document</h3>
              <p>
                If you're using jsdom or <a href="https://viperhtml.js.org/basic.html">basicHTML</a>,
                you can specify a temporary global document upfront, or change it at runtime.
              </p>
              <pre><code class="javascript">
              const {Document} = require('basichtml');

              // define document before requireing hyperHTML
              global.document = new Document();
              const hyperHTML = require('hyperhtml');

              // if you want to get rid of it
              delete global.document;
              </code></pre-->
              <!--h3 id="api-5">hyperHTML.adopt(element)</h3>
              <p>
                Created as the ideal <a href="https://viperhtml.js.org/viper.html">viperHTML</a> companion,
                targeting extreme graceful enhancement,
                adopting a node means trying to
                map interpolations from an existing content,
                as a best effort without losing input focus or current native status,
                whatever it is at the time of adoption.
              </p>
              <p>
                This is an inevitably limited, <strong>experimental</strong> feature
                that requires manual testing on every target device it's applied to.
              </p>
              <p>
                Beware, if the content of your template literal
                is not exactly the same as one used in viperHTML,
                and it's not a form element, input or select,
                you should avoid this method.
                Using it may increase the chance that the template will break in some target
                browser, and this method cannot guarantee the same reliability
                a bound element or a wire can.
              </p>
              <p>
                More documentation about this is coming soon.
              </p-->
            </section>
            <section id="components">
              <h2>Components</h2><hr>
              <p>
                There are different ways to use hyperHTML as a component driven library
                and none of them are strictly better than another.
                To get the best compatibility without needing too much
                transpiling or polyfills, you can keep things simple by using hyperHTML
                to generate regular HTML.
                You can also go all-in with Custom Elements and optionally Shadow DOM,
                as a more modern and elegant solution, mostly suitable for modern targets.
              </p>
              <h3 id="components-0">React<i>ish</i> Components</h3>
              <p>
                As shown in <a href="https://viperhtml.js.org/hyperhtml/examples/#!fw=React&example=Basic%20Component">this example</a>,
                it's possible to create components as functions or as classes.
              </p>
              <pre><code class="javascript">
              // as a function, same props, same node
              function Component(props) {
                return hyperHTML.wire(props)`
                &lt;h1&gt;Hello, ${props.name}&lt;/h1&gt;`;
              }
              
              // as a class, each instance
              // same node returned via obj.render()
              class Component {
                constructor(props) {
                  this.props = props;
                  this.html = hyperHTML.wire(this);
                }
                render() {
                  return this.html`
                  &lt;h1&gt;Hello, ${this.props.name}&lt;/h1&gt;`;
                }
              }
              </code></pre>
              <p>
                In these cases, there's no real need to create Custom Elements,
                and we could also style these components inline.
              </p>
              <p>
                I know that many would think this is heresy,
                but the truth is that it just works.
              </p>
              <pre><code class="javascript">
              // as function, same props, same node
              function MyH1(props) {'use strict';
                return hyperHTML.wire(props)`
                &lt;h1 style=${this.style}&gt;
                  Hello, ${props.name}
                &lt;/h1&gt;`;
              }
              
              MyH1.prototype.style = `
                background-color: black;
                color: white;
              `;
              
              document.body.appendChild(
                new MyH1({name: 'hyperHTML'})
              );
              </code></pre>
              <p>
                The example above, available on <a href="https://codepen.io/WebReflection/pen/YxEPQj?editors=0010">Code Pen</a>,
                abuses the usage of the inline <code>style</code> property,
                making our components less flexible when it comes to themes.<br>
                Using just a semantic <code>class</code> attribute would probably be a wiser choice.
              </p>
              <pre><code class="javascript">
              function MyH1(props) {'use strict';
                return hyperHTML.wire(props)`
                &lt;h1 class=${props.class || this.class}&gt;
                  Hello, ${props.name}
                &lt;/h1&gt;`;
              }
              
              MyH1.prototype.class = 'regular-h1';
              </code></pre>
              <p>
                In the example above it's possible to change all components by simply specifying
                a different <code>class</code> value or passing one in case the related object
                has a special meaning (i.e. it's an <code>active</code> H1).
              </p>
              <p>
                Last, but not least, if you don't need inheritance,
                you can just use regular functions without needing the <code>new</code>
                operator in your code.
              </p>
              <pre><code class="javascript">
              function myH1(props) {
                return hyperHTML.wire(props)`
                &lt;h1 class=my-h1&gt;
                  Hello, ${props.name}
                &lt;/h1&gt;`;
              }
              
              document.body.appendChild(
                myH1({name: 'hyperHTML'})
              );
              </code></pre>
              <p>
                Try the example above on <a href="https://codepen.io/WebReflection/pen/ayVzjE?editors=0010">Code Pen</a>.
              </p>
              <h3 id="components-1">Polymer<i>ish</i> Components</h3>
              <p>
                A modern approach to components is best represented by the Polymer project:
                it's based on modern Web platform standards, and it's the right tool for the problem it's trying to solve.
              </p>
              <p>
                With hyperHTML you can also use Custom Elements right away,
                optionally including a <a href="https://github.com/WebReflection/document-register-element">proper polyfill</a> upfront when needed.
              </p>
              <pre><code class="javascript">
              class MyComponent extends HTMLElement {
                static get observedAttributes() { return ['name']; }
                constructor(...args) {
                  super(...args);
                  this.html = hyperHTML.bind(this);
                }
                attributeChangedCallback() { this.render(); }
                connectedCallback() { this.render(); }
                render() {
                  return this.html`
                  &lt;h1&gt;Hello, ${this.getAttribute('name')}&lt;/h1&gt;`;
                }
              }
              
              customElements.define('my-component', MyComponent);
              
              document.body.innerHTML =
                '&lt;my-component name="First"&gt;&lt;/my-component&gt;';
              
              const mc = new MyComponent;
              mc.setAttribute('name', 'Second');
              document.body.appendChild(mc);
              </code></pre>
              <p>
                Verify the result on <a href="https://codepen.io/WebReflection/pen/yoPNaz?editors=0010">Code Pen</a>.
              </p>
              <h4>About Shadow DOM</h4>
              <p>
                There are no special rules to remember with Shadow DOM
                because behind the scenes hyperHTML uses a <code>template</code>
                element so if you bind a Shadow DOM element to hyperHTML, everything will just work.
              </p>
              <p>
                In this <a href="https://codepen.io/WebReflection/pen/eEeNRr?editors=0010">Code Pen</a> example,
                you can see that even the closed Shadow DOM is just fine as hyperHTML context.
              </p>
              <pre><code class="javascript">
              class MyComponent extends HTMLElement {
                ...
                constructor(...args) {
                  super(...args);
                  this.html = hyperHTML.bind(
                    this.attachShadow({mode: 'closed'})
                  );
                }
                ...
              }
              </code></pre>
              <p>
                Be sure your target browser supports Shadow DOM
                then go wild with Custom Elements and hyperHTML!
              </p>
              <h3 id="components-2">HyperHTMLElement Class</h3>
              <p>
                The goal of <a href="https://github.com/WebReflection/hyperHTML-Element">HyperHTMLElement</a> 
                is to be an ideal companion to hyperHTML itself.<br>
                It removes all the repeated, boring and sometimes problematic setup steps needed
                to define Custom Elements. This makes their creation a no-brainer.
                Have a look at the <a href="https://viperhtml.js.org/hyperhtml/examples/#!fw=Polymer&example=custom-element">comparisons VS Polymer</a>.
              </p>
              <p>
                Below are some <code>HyperHTMLElement</code> class features:
              </p>
              <ul>
                <li><code>created()</code> a reliable entry point to setup components,
                including injecting text content, html, or shadow dom</li>
                <li>automatic <code>observedAttributes</code> accessors
                to react to when you change an attribute directly instead of passing through
                the verbose and boring <code>comp.setAttribute(name, value)</code></li>
                <li>a lazy <code>html</code> read-only property that will create content in the right place: the node itself or its shadow DOM, if previously defined.</li>
                <li>convenient access to child elements with `ref` attribute via `this.refs[name]`, e.g. `<input ref="email" type="email">` accessible as `this.refs.email`</li>
                <li>automatic <strong>bound events</strong> without the usual binding overhead through native <code>handleEvent</code> behavior,
                as <a href="https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38">described in this post</a>,
                or through lazy method binding like <code>handleClick</code> and others.</li>
                <li>simple <strong>state handling</strong> through the <code>comp.setState(objOrFn)</code> standard with automatic invocation of the <code>render()</code> method.</li>
                <li>easy default state definition via <code>get defaultState() { return {}; }</code></li>
              </ul>
              <p>
                Please note <code>HyperHTMLElement</code> exposes same <code>hyperHTML</code> methods.<br>
                There is no need to include both scripts in the same page.
              </p>
              <pre>&lt;script src="//unpkg.com/hyperhtml@latest/min.js"&gt;&lt;/script&gt;</pre>
              <p>
                At this point, you should be good to go and ready to create amazing PWAs!
              </p>
              <h4>About <code>this.html</code></h4>
              <p>
                Lazily defined once per instance, <code>this.html</code> can be:
              </p>
              <ul>
                <li>the bound element itself, if no shadow dom has been attached once created</li>
                <li>the element <code>shadowRoot</code>, if openly attached once created</li>
                <li>the element <code>_shadowRoot</code>, if the shadow has been created as <code>this._shadowRoot = this.attachShadow({mode:'closed'});</code></li>
              </ul>
              <p>
                The latter attempt is the last resort to find an otherwise hard to reach, closed shadowRoot
                but if you regularly use opened shadows, the <code>shadowRoot</code> node will be automatically available ( suggested ).
              </p>
              <h3 id="components-3">hyper.Component</h3>
              <p>
                If previous solutions didn't satisfy your requirements,
                version 1.6 introduced a minimalistic Component approach
                based on the following features:
              </p>
              <ul>
                <li><strong>no custom elements</strong> needed. Forget polyfills and issues with classes extending built-in classes, it just works with regular HTML.</li>
                <li><strong>automatic wire</strong> via lazy assignment. Just render returning <code>this.html`...`</code> or  <code>this.svg`...`</code> without caring about hyperHTML at all.</li>
                <li><strong>basic state handling</strong> through a Preact<i>ish</i> method such <code>setState(objOrCallback)</code>, including the ability to define a <code>defaultState</code> accessor.</li>
                <li><strong>simplified event handling</strong> directly borrowed by HyperHTMLElement behavior.</li>
                <li><strong>onconnected</strong> and <strong>ondisconnected</strong> events out of the box</li>
                <li><strong>Component.for(context, uid)</strong> utility to simplify creation of sub components within any render</li>
                <li><strong>simplified dispatch</strong> to use the first available node and dispatch cancelable, bubbling, custom events with a <code>component</code> property and arbitrary <code>detail</code> data</li>
              </ul>
              <p>
                The following examples represent <code>hyper.Component</code> features in a nutshell.
              </p>
              <pre><code class="javascript">
              class Clock extends hyper.Component {
                get defaultState() { return {date: new Date()}; }
                onconnected() {
                  console.log('finally live');
                }
                render() {
                  return this.html`
                    &lt;div onconnected=${this} &gt;
                      &lt;h1&gt;Hello, world!&lt;/h1&gt;
                      &lt;h2&gt;It is ${
                        this.state.date.toLocaleTimeString()
                      }.&lt;/h2&gt;
                    &lt;/div&gt;`;
                }
              }
              </code></pre>
              <p><a href="https://codepen.io/WebReflection/pen/ZJVNEp?editors=0010">Code Pen</a></p>
              <pre><code class="javascript">
              class Counter extends hyper.Component {
                get defaultState() {
                  return {css: 'font-weight:bold;', count: 0};
                }
                constructor(count) {
                  super();
                  this.setState({count});
                }
                onclick() {
                  this.setState(prev => ({count: prev.count + 1}));
                }
                render() {
                  return this.html`
                    &lt;button style=${this.state.css} onclick=${this}&gt;
                      ${this.state.count}
                    &lt;/button&gt;`;
                }
              }
              </code></pre>
              <p><a href="https://codepen.io/WebReflection/pen/YxdbyO?editors=0010">Code Pen</a></p>
              <p>
                Differently from most other frameworks, components don't really need a top level element.
              </p>
              <pre><code class="javascript">
              class ArrowPad extends hyper.Component {

                left() { this.setState({action: 'left'}); }
                up() { this.setState({action: 'up'}); }
                bottom() { this.setState({action: 'bottom'}); }
                right() { this.setState({action: 'right'}); }

                setState(state) {
                  super.setState(state);
                  this.dispatch('new-state', state);
                }

                render() { return this.html`
                  &lt;button data-call=left onclick=${this}&gt;◂&lt;/button&gt;
                  &lt;button data-call=up onclick=${this}&gt;▴&lt;/button&gt;
                  &lt;button data-call=bottom onclick=${this}&gt;▾&lt;/button&gt;
                  &lt;button data-call=right onclick=${this}&gt;▸&lt;/button&gt;
                  &lt;p&gt;Last action: ${this.state.action}&lt;/p&gt;`;
                }
              }
              </code></pre>
              <p><a href="https://codepen.io/WebReflection/pen/YxdbpR?editors=0010">Code Pen</a></p>
              <p>
                The static <code>Component.for(context[, uid])</code> utility helps solving tedious sub-components initialization.
              </p>
              <pre><code class="javascript">
              class List extends Component {
                constructor(items) {
                  super().items = items;
                }
                render() {
                  return this.html`
                  &lt;ul&gt;${this.items.map(
                    item => ListItem.for(item)
                  )}&lt;/ul&gt;`;
                }
              }
              </code></pre>
              <p><a href="https://codepen.io/WebReflection/pen/ZxjdZQ?editors=0010">Code Pen</a></p>
            </section>
            <section id="testing">
              <h2>Testing</h2><hr>
              <p>
                hyperHTML is easy to test in the browser and in NodeJS.
                If you're testing in NodeJS you will, however, need a JavaScript implementation of the DOM (<a href="https://github.com/WebReflection/basicHTML">basicHTML</a> or <a href="https://github.com/tmpvar/jsdom">jsdom</a>). 
              </p>
              <h3 id="testing-0">NodeJS</h3>
              <p>
                With NodeJS, if you're using basicHTML or jsdom you can use the same, familiar syntax you would when querying and interacting with the DOM in the browser.
              </p>
              <p>
                The following is a basic <a href="https://runkit.com/embed/jz7xffvshlz0">NodeJS example</a> test.
              </p>
              <h3 id="testing-1">Browser</h3>
              <p>
                You can test right away with any testing framework you'd like, as you can see in the <a href="https://codepen.io/WebReflection/pen/eErVLz?editors=0010">Browser example</a> test.
              </p>
            </section>
            <section id="extras">
              <h2>Extras</h2><hr>
              <p>
                This section is dedicated to F.A.Q. and other less important topics around hyperHTML.
              </p>
              <h3 id="extras-0">Hyper Hyper Text ?</h3>
              <p>
                Few developers asked me about the apparently redundant name.
              </p>
              <p>
                First of all, it's worth underlying that who used hyperHTML never cared or complained about its name.<br>
                They rather instantly appreciated the library innovative and revolutionary approach to solve a common problem
                in such compact, elegant, standard, and also performant way: pick 4 of them.
              </p>
              <p>
                For the little stats I have, it also looks like people complaining about the name are those that
                never used the library, but decided to already have an opinion about it.
              </p>
              <p>
                Maybe they also need to find an<small>(y)</small> excuse to avoid trying such library,
                believing what they use daily is better and solved all their problems already.
              </p>
              <p>
                Well, if that's the case, congratulations!
              </p>
              <p>
                Regardless, maybe not everyone knows that <a href="http://dictionary.cambridge.org/dictionary/english/hyper">hyper</a>,
                which means <em>too excited and energetic</em>, and <a ref="http://dictionary.cambridge.org/dictionary/english/hypertext">hypertext</a>,
                which is <em>a way of joining a word or image to another page, document, etc. on the internet or in another computer program so that you can move from one to the other easily</em>,
                are <strong>two completely different words</strong>.
              </p>
              <p>
                Java is not JavaScript,
                ham is not hamster,
                and you can have a steelyard made of steel too!
              </p>
              <p>
                But even if you made up your mind before trying hyperHTML,
                and you think that having a more exciting way to declare Hypertext Markup Language doesn't make sense,
                I'd like to tell the story behind the name.
              </p>
              <h4>innerHTML vs hyperHTML</h4>
              <p>
                Binding HTML to a node context, looks very similar to the old way to inject HTML during 00's.
              </p>
              <pre><code class="javascript">
              // what the Web used to do
              // attributes and content are unsafe
              // XSS prone, and full of undesired surprises
              document.body.innerHTML = [
                '&lt;div class="', className, '"&gt;',
                  textContent
                '&lt;/div&gt;'
              ].join();

              // hyperHTML is safe by default
              // but it looks similar, if not easier
              hyperHTML.bind(document.body)`
              &lt;div class=${className}&gt;
                ${textContent}
              &lt;/div&gt;`;
              </code></pre>
              <p>
                If reminding the good old days, emphasizing enhanced features, wasn't enough,
                <code>inner</code> and <code>hyper</code> words also differs for just 3 chars.
              </p>
              <p>
                Last, but not least, hyperHTML is part of a wider family,
                including <a href="https://viperhtml.js.org/viper.html">viperHTML</a> and
                <a href="https://viperhtml.js.org/basic.html">basicHTML</a>.
              </p>
              <p>
                Accordingly, if you connect the word <em>hyper</em> with some Front End meaning,
                you'll never be confused by what project you need for what.
              </p>
              <p>
                Is it Front-End? hyperHTML.<br>
                Back-End? viperHTML.<br>
                Do you need basic HTML on your project? basicHTML it is.<br>
                And so on ...
              </p>
              <h4>Still not convinced?</h4>
              <p>
                Imagine the <a href="https://github.com/tc39/proposal-bind-operator">bind operator</a> will become popular and you will be able to write
                valid JavaScript syntax like:
              </p>
              <pre><code class="javascript">
              document.body::hyperHTML`
              &lt;div&gt;This is the content.&lt;/div&gt;`;
              </code></pre>
              <p>
                Do you feel any better about the name now? 😃
              </p>
              <p>
                If not, put in this way: if the name is the only complain you ever heard about a library,
                maybe it means it's that good, and you should really give it a try! 😜
              </p>
              <h3 id="extras-1">hyperHTML vs lit-html</h3>
              <p>
                Since many have asked about the differences between these two libraries,
                I've written <a href="https://gist.github.com/WebReflection/fadcc419f5ccaae92bc167d8ff5c611b">a gist full of explanations and examples</a>.
              </p>
              <p>
                Please note that lit-html is still experimental, while hyperHTML is ready for production
                so it's probably too early to fully compare both.
              </p>
            </section>
          </div>
        </div>
      </div>
    </section>
  </body>
</html>
